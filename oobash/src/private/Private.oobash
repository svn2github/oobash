##################################################################
# Author:  andreas.gregor.frank@googlemail.com                                
#     
# License: The MIT License
#
# Copyright (c) <2010> <andreas.gregor.frank@googlemail.com>

#######################
#######################
##                   ##
##      PRIVATE      ## 
##                   ##
#######################
#######################

# Index of content:
# __getObjectPointer() returns pointer of given object
# __getFileBase() returns file name without file extension
# __visibilityCheck() check if given string is visible
# __keywordCheck() checks if objectname argument for a constructor is a keyword
# __periodCheck() check if given string contains "." character
# __slashCheck() check if given string contains "/" character
# __isObjectnameValid() checks all constructor args
# __throw() throws an exception with name of exception and message
# __attribute() stores an attribute of an object
# __destruct() destroys a given object
# __unalias() deletes all bash aliases for an object (object.method=object.method)
# __alias() creates all bash aliases for an object (object.method=object.method)
# __strUpper() returns given string uppercase
# __strLower() returns given string lowercase
# __mathConverter() validates and converts input for valid input for the math methods
# __rstripDoubleZeros() strips ending zeros
# __posixFilePermissionToOctal() converts a "rwxrwxrwx" file permission string to octal
# __i18nMessage() translates and prints message to given channel
# __cleanUpObjectsPool() destroys all objects
# __cleanUpFunctions() unsets all functions
# __cleanUpClasses() unsets all class constructors, class arrays, class help functions, class methods
# __cleanUpVars() unsets the registered variables
# __dependencyCheck() check for external commands (element of __Dependencies__ array) that are used in this framework
# __gnudateCheck() check for gnu date
# __gnustatCheck() checks for gnu stat
# __handleErrorMessage() decision: call stacktrace or help or nothing
# __tracebackHeader() prints the traceback header to stderr
# __stacktrace() generates stacktrace
# __isAssocArray() checks if given parameter is an associative array
# __stripPath() strips double and trailing "/" characters in given path
# __isBashInteger() check for integer input and size of int
# __localDateFormat() returns the local date format (depends on LANG setting)
# __decoratorCheck() function to handle decorators, if there are some
# __isatty() checks if a given file descriptor refers to a terminal
# __charCode() returns the charcter code of first letter of given string
# __lookForLoggingPropertiesFile() check for log4oobash.properties file in the same directory from where this file gets sourced
# __terminalSupportsColors() asks local terminal database if this terminal supports colours
# __getLoggingTimestamp() returns a timestamp
# __isXTRACEFDAvailable() checks if BASH_XTRACEFD is available with this bash version
# __getFreeFD() tries to return a free file descriptor
# __ps4IndirectionLevelIndentation sets 3 spaces indentation for every level of indirection in PS4
# __setPS4() sets PS4 prompt for a better prefix during tracing output
# __wordSort(): sorts some words (alphabetically)
##########
# UNUSED #
##########
# __getAttributeFromObjectByName() returns the value of a given attribute of a given object
# __isWriteable() checks if given parameter is writeable
# __isArray() checks if given parameter is an array


# private
# returns pointer of given object
# Called by:
# __getSshHost
# __getSshUser
# __getSshPort
# __toInt
# __getSyslogEquivalent
# __getPid
# __toString
# __getAttributeFromObjectByName
__getObjectPointer() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local this="$1"
   local key char pointer str
   declare -i i j
   for key in "${!__OBJECTPOOL__[@]}"
   do
      if [[ "$this" == "$key" ]]; then
         str="${__OBJECTPOOL__["$this"]}"
         for ((i=0; i < ${#str}; i++))
         do
            char="${str:i:1}"
            if [[ $char == "@" ]]; then
               j=$((++i))
               pointer="${str:j}"
            fi
         done
      fi
   done
   System.out.println "${pointer}"
   return 0
}
__registerFunction __getObjectPointer

# private
# returns file name without file extension
# called by:
# getBase (File)
# __lookForLoggingPropertiesFile
__getFileBase() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   arg="$1"
   local file="$(__basename "$arg")"
   local path="$(__dirname "$arg")"
   # test for hidden file
   if [[ ! -z "${file%.*}" ]]; then
      System.out.println "$(__stripPath "${path}"/"${file%.*}")"
   else
      System.out.println "$(__stripPath "${path}"/"${file}")"
   fi
   return 0
}
__registerFunction __getFileBase

# private
# check if given string is visible 
# called by:
# __objectnameCheck
# -isVisible
__visibilityCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local str="$1"
   local unsetAtEnd="$(Boolean.FALSE)" 
   local bool="$(Boolean.FALSE)" 
   # is extglob set ?
   shopt -q extglob
   # if extglob not set already --> set it now and change boolean 
   if (( $? == 1 )); then
      shopt -s extglob
      unsetAtEnd="$(Boolean.TRUE)"
   fi 
   if [[ "$str" != "" ]]; then
      if [[ "${str##+([[:graph:]])}" == "" ]]; then
         bool="$(Boolean.TRUE)"
      fi      
   fi       
   if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
      shopt -u extglob
   fi
   if [[  "${bool}" == "$(Boolean.TRUE)" ]]; then
      return 0
   else
      return 1
   fi
}
__registerFunction __visibilityCheck

# private
# checks if objectname argument 
# for a constructor is a keyword
# called by:
# __objectnameCheck
__keywordCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local word="$1"
   local keyword
   for keyword in ${__Keywords__[@]}
   do 
      if [[ "${word}" == "${keyword}" ]]; then
         return 1
      fi
   done
   return 0
}
__registerFunction __keywordCheck
__registerVar __Keywords__

# private
# check if given string contains "." character 
# called by:
# __objectnameCheck
__periodCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local str="$1"
   local char
   declare -i i
   for ((i=0; i < ${#str}; i++))
   do
      char="${this:i:1}"
      case "${char}" in
         .) return 1;;
      esac
   done
   return 0
}
__registerFunction __periodCheck

# private
# check if given string contains "/" character 
# called by:
# __objectnameCheck
__slashCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local str="$1"
   local char
   declare -i i
   for ((i=0; i < ${#str}; i++))
   do
      char="${this:i:1}"
      case "${char}" in
         /) return 1;;
      esac
   done
   return 0
}
__registerFunction __slashCheck

# private
# checks all constructor args
# cales by:
# every constructor
__isObjectnameValid() {
   if ! __visibilityCheck "$this"; then
      __throw "IllegalArgumentException" ": Objectname '$this' is not valid"
      return $?
   fi

   if ! __keywordCheck "$this"; then
      __throw "IllegalArgumentException" ": Objectname '$this' is a keyword"
      return $?
   fi

   if ! __periodCheck "$this"; then
      __throw "IllegalArgumentException" ": No full stop character allowed in objectname"
      return $?
   fi
   
   if ! __slashCheck "$this"; then
      __throw "IllegalArgumentException" ": No slash character allowed in objectname"
      return $?
   fi
   return 0
}
__registerFunction __isObjectnameValid

# private
# throws an exception with name of exception and message
# called by:
# every public method
# and __dependencyCheck
__throw() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   local exception="$1"
   local message="$2"
   __tracebackHeader
   System.err.println "${exception}${message}"
   if [[ ! -z "${__ExceptionValues__[$exception]}" ]]; then
      returnValue=${__ExceptionValues__[$exception]}
   else   
      returnValue=${__ExceptionValues__[Unknown]}
   fi
   return $returnValue
}
__registerFunction __throw

# private  
# stores an attribute of an object
# called by:
# -every constructor
__attribute() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local key="$1"
   local value="$2"
   __OBJECTPOOL__["${this}"]=$class@$pointer
   __ATTRIBUTEPOOL__["${pointer}"@"${key}"]="$value"
   return 0
}
__registerFunction __attribute

# private  
# destroys a given object
# called by:
# -every constructor
# __cleanUpObjectsPool
__destruct() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local this="$1"
   local string="${__OBJECTPOOL__["${this}"]}"
   if [[ ! -z "${string}" ]]; then
      local char pointer lastClass
      declare -i i=0
      for ((i=0; i < ${#string}; i++))
      do
         char="${string:i:1}"
         if [[ ${char} == "@" ]]; then
            (( i++ ))
            pointer="${string:i}"
            lastClass="${string:0:(i-1)}"
            break
         fi
      done
      unset __OBJECTPOOL__["${this}"]
      
      local key
      for key in "${!__ATTRIBUTEPOOL__[@]}"
      do
         if [[ "${key}" == "${pointer}"@* ]]; then
            unset __ATTRIBUTEPOOL__["${key}"]
         fi      
      done

      __unalias "$this" "$lastClass"
   fi
   return 0
}
__registerFunction __destruct

# private
# deletes all bash aliases for an object
# (object.method=object.method).
# Only active in interactive bash
# called by:
# -every constructor
if [[ ! -z "$PS1" ]]; then
   __unalias() {
      __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
      local this="$1"
      local lastClass="$2"
      local method
      for method in $(eval echo \${__${lastClass}__[@]})
      do
         unalias "${this}"."${method}" 2>/dev/null
      done
      return 0
   }
else
   __unalias() {
      :
      return 0
   }
fi
__registerFunction __unalias

# private
# creates all bash aliases for an object
# (object.method=object.method).
# Only active in interactive bash
# The alias does not avoid the 
# "command not found"-situation,
# but you can enjoy autocompletion
# in the interactive bash. 
# called by:
# -every constructor
if [[ ! -z "$PS1" ]]; then
   __alias() {
      __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
      local this="$1"
      local class="$2"
      local method
      for method in $(eval echo \${__${class}__[@]})
      do
         BASH_ALIASES["${this}"."${method}"]=""${this}"."${method}""
      done
      return 0
   }   
else
   __alias() {
      :
      return 0
   }
fi
__registerFunction __alias

# private  
# returns given string uppercase
# called by:
# -__compareToIgnoreCase
# -__toUpperCase
# -__capitalize
# -__title
__strUpper() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -u str="$1"
   local upper=''
   local char
   local valueOf
   declare -i i=0
   for ((i=0; i < ${#str}; i++))
   do
      char="${str:i:1}"
      valueOf=$(__charCode "$char")
      case "${valueOf}" in
         # small sharp s 
         223 )                  
            upper="${upper}""ẞ";;
         228|246|252|224|226|230|231|232|233|\
         234|235|238|239|244|339|249|251|261|\
         281|243|263|322|324|347|378|380|225|\
         237|241|250|259|537|351|539|355|283|\
         367|253|269|314|328|341|345|353|382|\
         271|357|248|229|337|369|236|242|240|\
         254|\
         1072|1073|1074|1075|1076|1077|1078|1079|\
         1080|1081|1082|1083|1084|1085|1086|1087|\
         1088|1089|1090|1091|1092|1093|1094|1095|\
         1096|1097|1098|1099|1100|1101|1102|1103|\
         1104|1105|1106|1107|1108|1109|1110|1111|\
         1112|1113|1114|1115|1116|1117|1118|1119)  
            upper="${upper}""${char~}";;       
         * ) 
            upper="${upper}""${char}" ;;
      esac
   done
   System.out.println "${upper}"
   return 0   
}
__registerFunction __strUpper

# private
# returns given string lowercase
# called by:
# -__toLowerCase
# -__title
__strLower() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -l str="$1"
   local lower=''
   local char
   local valueOf
   declare -i i=0
   for ((i=0; i < ${#str}; i++))
   do
      char="${str:i:1}"
      valueOf=$(__charCode "$char")
      case $valueOf in
         # uppercase sharp s
         7838)
            lower="${lower}""ß";;
         220|196|214|192|194|198|199|200|201|\
         202|203|206|207|212|338|217|219|260|\
         280|211|262|321|323|346|377|379|193|\
         205|209|218|258|536|350|538|354|282|\
         366|221|268|313|327|340|344|352|381|\
         270|356|216|197|336|368|204|210|208|\
         222|\
         1024|1025|1026|1027|1028|1029|1030|1031|\
         1032|1033|1034|1035|1036|1037|1038|1039|\
         1040|1041|1042|1043|1044|1045|1046|1047|\
         1048|1049|1050|1051|1052|1053|1054|1055|\
         1056|1057|1058|1059|1060|1061|1062|1063|\
         1064|1065|1066|1067|1068|1069|1070|1071)
            lower="${lower}""${char~}";; 
         * ) 
            lower="${lower}""${char}" ;;
      esac
   done
   System.out.println "${lower}"
   return 0
}
__registerFunction __strLower

# private
# validates and converts input 
# for valid input for the math methods.
# bc is used in the math methods
# to do the calculations.
# called by:
# -Math.sin
# -Math.cos
# -Math.tan
# -Math.atan
# -Math.asin
# -Math.acos
# -Math.max
# -Math.min
# -Math.abs
# -Math.sqrt
# -Math.exp
# -Math.expm1
# -Math.sinh
# -Math.cosh
# -Math.tanh
# -Math.adder
# -Math.multiplier
# -Math.log
# -Math.log10
# -Math.log1p
# -Math.toDegrees
# -Math.toRadians
# -Math.ceil
# -Math.floor
# -Math.hypot
# -Math.cbrt
__mathConverter() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local input="$1"

   case "${input}" in
      NaN|Infinity|-Infinity) System.out.println "${input}"
                              return 0;;
   esac

   if [[ "${input}" =~ ^[-]?[0-9]*\.?[0-9]+([eE][-]?[0-9]+)+$ ]]; then
      set -o noglob
      System.out.println "${input/[eE]/ * 10 ^ }"
      set +o noglob 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[+]?[0-9]*\.?[0-9]+([eE][-]?[0-9]+)+$ ]]; then
      set -o noglob
      output="${input/[eE]/ * 10 ^ }"
      System.out.println "${output:1}"
      set +o noglob 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[-]?[0-9]*\,?[0-9]+([eE][-]?[0-9]+)+$ ]]; then
      set -o noglob
      output="${input/[eE]/ * 10 ^ }"
      System.out.println "${output/,/.}"
      set +o noglob 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[+]?[0-9]*\,?[0-9]+([eE][-]?[0-9]+)+$ ]]; then
      set -o noglob
      output="${input/[eE]/ * 10 ^ }"
      output="${output:1}"
      System.out.println "${output/,/.}"
      set +o noglob 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[-]?[0-9]*\.?[0-9]+([eE][+]?[0-9]+)+$ ]]; then
      set -o noglob
      System.out.println "${input/[eE]+/ * 10 ^ }"
      set +o noglob 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[+]?[0-9]*\.?[0-9]+([eE][+]?[0-9]+)+$ ]]; then
      set -o noglob
      output="${input/[eE]+/ * 10 ^ }"
      System.out.println "${output:1}"
      set +o noglob 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[-]?[0-9]*\,?[0-9]+([eE][+]?[0-9]+)+$ ]]; then
      set -o noglob
      output="${input/[eE]+/ * 10 ^ }"
      System.out.println "${output/,/.}"
      set +o noglob 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[+]?[0-9]*\,?[0-9]+([eE][+]?[0-9]+)+$ ]]; then
      set -o noglob
      output="${input/[eE]+/ * 10 ^ }"
      output="${output:1}"
      System.out.println "${output/,/.}"
      set +o noglob 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[-]?([0-9]*\.[0-9]+|[0-9]+)$ ]]; then
      System.out.println $input
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[+]?([0-9]*\.[0-9]+|[0-9]+)$ ]]; then
      System.out.println "${input:1}"
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[-]?([0-9]*\,[0-9]+|[0-9]+)$ ]]; then
      System.out.println "${input/,/.}"
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[+]?([0-9]*\,[0-9]+|[0-9]+)$ ]]; then
      output="${input:1}"
      System.out.println "${output/,/.}" 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[-]?[0-9]+$ ]]; then
      System.out.println "${input}"
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi  
      return 0
   elif [[ "${input}" =~ ^[+]?[0-9]+$ ]]; then
      System.out.println "${input:1}"
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi  
      return 0
   fi
   if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
      shopt -u extglob
   fi  
   # Cannot recognize...
   return 1
}
__registerFunction __mathConverter

# private
# strips ending zeros
# called by:
# -Math.random 
# -Math.cos 
# -Math.sin 
# -Math.tan 
# -Math.atan
# -Math.asin 
# -Math.acos 
# -Math.sqrt 
# -Math.exp 
# -Math.adder 
# -Math.multiplier
# -Math.log 
# -Math.log10 
# -Math.log1p 
# -Math.cbrt
# -Math.hypot
# -Math.toRadians
# -Math.toDegrees
# -Math.sinh
# -Math.cosh
# -Math.tanh
__rstripDoubleZeros() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   local str="$1" result="$1"
   if [[ "$str" != "${str/./}" ]]; then
      local unsetAtEnd=$(Boolean.FALSE) 
      # is extglob set ?
      shopt -q extglob
      # if extglob not set already --> set it now and change boolean
      if (( $? == 1 )); then
         shopt -s extglob
         unsetAtEnd=$(Boolean.TRUE)
      fi 
      shopt -s extglob
      # trimming...
      result="${str%%+(0)}"
      if [[ ${result: -1} == "." ]]; then
         result="${result}"0
      fi
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
   fi
   System.out.println "${result}"
   return $returnValue
}
__registerFunction __rstripDoubleZeros

# private
# converts a "rwxrwxrwx" file permission
# string to octal (eg 777)
# called by:
# -__hasUidBit
# -__hasGidBit
# -__setPosixFilePermissions
# -__setuid
# -__setgid
# -__setStickyBit
# -File.createTemporaryFile
# -File.createTemporaryDir
__posixFilePermissionToOctal() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local unsetAtEnd=$(Boolean.FALSE) 
   # is extglob set ?
   shopt -q extglob
   # if extglob not set already --> set it now and change boolean 
   if (( $? == 1 )); then
      shopt -s extglob
      unsetAtEnd=$(Boolean.TRUE)
   fi 
   local permissions="$1"
   local octal=''
   declare -i octalPerm=0
   declare -i highOrderOctal=0
   if [[ "${permissions}" =~ ^([r-][w-][xsS-]){2}[r-][w-][xtT-]$ ]]; then
      # convert to octal format
      local perm
      declare -i i=0
      for ((i=0; i < 9; i++))
      do
         perm="${permissions:i:1}"
         case ${perm} in
            r)octalPerm=$(($octalPerm+4));;
            w)octalPerm=$(($octalPerm+2));;
            s)octalPerm=$(($octalPerm+1))
              if (( $i == 2)); then
                 highOrderOctal=$(($highOrderOctal+4))
              else
                 highOrderOctal=$(($highOrderOctal+2))
              fi;;
            S)if (( $i == 2)); then
                 highOrderOctal=$(($highOrderOctal+4))
              else
                 highOrderOctal=$(($highOrderOctal+2))
              fi;;
            x)octalPerm=$(($octalPerm+1));;
            t)octalPerm=$(($octalPerm+1))
              highOrderOctal=$(($highOrderOctal+1));;
            T)highOrderOctal=$(($highOrderOctal+1));;
         esac
         # starting with 0
         if (( $i == 2 || $i == 5 || $i== 8 )); then
            octal=${octal}${octalPerm}
            octalPerm=0  
         fi        
      done
   else
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi
      return 1
   fi
   if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
      shopt -u extglob
   fi
   System.out.println "${highOrderOctal}${octal}"
   return 0
}
__registerFunction __posixFilePermissionToOctal

# private
# translates and prints message to given channel
# called by:
# -I18n.err.print -I18n.out.print -I18n.err.println -I18n.out.println
__i18nMessage() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local message="$1"
   # msgid "" can be mapped to meta informations 
   if [[ "${message}" == "" ]]; then
       System.${printStream}.${print} ""
   else
      if command -v eval_gettext >/dev/null 2>&1; then
         System.${printStream}.${print} "$(eval_gettext "$message")"
      else
         # fall back to old school bash i18n
         System.${printStream}.${print} "$(eval System.out.println \$"\"${message}\"")"
      fi
   fi
   return 0
}
__registerFunction __i18nMessage

# private  
# destroys all objects.
# does not need registration. unset action in __cleanUp function (Registry)
# called by:
# __cleanUp
__cleanUpObjectsPool() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local obj
   for obj in ${!__OBJECTPOOL__[@]} 
   do 
      __destruct "${obj}"
   done
   return 0
}

# private  
# unsets all functions.
# does not need registration. unset action in __cleanUp function. (Registry)
# called by:
# __cleanUp
__cleanUpFunctions() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local value
   for value in ${!__Registry__[@]}
   do 
      if [[ "${__Registry__[$value]}" == "function" ]]; then
         unset -f "${value}" 
      fi
   done
   return 0
}

# private  
# unsets all class constructors, class arrays, class help functions, class methods.
# does not need registration. unset action in __cleanUp function (Registry)
# called by:
# __cleanUp
__cleanUpClasses() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local value
   local meth
   for value in ${!__Registry__[@]}
   do 
      if [[ "${__Registry__[$value]}" == "class" ]]; then
         for meth in $(eval echo \${__${value}__[@]})
         do
            unset -f "__${meth}"
         done
         unset $(eval echo __${value}__  __${value}Methods__)
         unset -f $(eval echo $value ${value}.help)
      fi
   done
   return 0
}

# private  
# unsets the registered variables.
# does not need registration. unset action in __cleanUp function (Registry)
# called by:
# __cleanUp
__cleanUpVars() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local value
   for value in ${!__Registry__[@]}
   do 
      if [[ "${__Registry__[$value]}" == "var" ]]; then
         unset "${value}"
      fi
   done   
   return 0
}

# private
# check for external commands that are used in this framework
# Throws:
#    NotInPathException - if element of __Dependencies__ array is not in path
# called by:
# every time you source this framework
__dependencyCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local bool="$(Boolean.TRUE)"
   declare -i i
   for ((i=0; i < ${#__Dependencies__[@]}; i++))
   do
      if ! command -v ${__Dependencies__[i]} >/dev/null 2>&1; then
         bool="$(Boolean.FALSE)"
         __throw "NotInPathException" ": ${__Dependencies__[i]} not in path"
      else
         case "${__Dependencies__[i]}" in
            date) if ! __gnudateCheck; then
                     bool="$(Boolean.FALSE)"
                     __throw "NotInPathException" ": GNU date not in path"
                  fi;;
            stat) if ! __gnustatCheck; then
                     bool="$(Boolean.FALSE)"
                     __throw "NotInPathException" ": GNU stat not in path"
                  fi;;
            readlink) if ! __gnureadlinkCheck; then
                         bool="$(Boolean.FALSE)"
                         __throw "NotInPathException" ": GNU readlink not in path"
                      fi;;                      
         esac
      fi
   done
   if [[ "${bool}" == "$(Boolean.TRUE)" ]]; then
      return 0
   else
      return 1
   fi
}
__registerFunction __dependencyCheck

# private
# check for gnu date
# called by:
# __dependencyCheck
# System.currentTimeMillis
# System.currentTimeNanos
# System.runtime
#__setLastModified
__gnudateCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   # For this framework it is important to work with a gnu date, so:
   # special check for gnu date with nanoseconds gnu feature:
   if command -v date >/dev/null 2>&1; then
      local testtimestamp
      testtimestamp="$(date "+%N" 2>/dev/null)"
      if [[ "${testtimestamp: -1}" == "N" ]]; then
         return 1
      fi
   else
      return 1
   fi
   return 0
}
__registerFunction __gnudateCheck

# private
# check for gnu stat
# called by:
# __dependencyCheck
# __getTotalSpace
# __getUsableSpace
# __getFreeSpace
# __lastModified
__gnustatCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   # For this framework it is important to work with a gnu stat, so:
   # special check for gnu stat with "--file-system" gnu feature:
   if command -v stat >/dev/null 2>&1; then
      stat --file-system / 2>/dev/null 1>&2
      if (( $? != 0 )); then
         return 1
      fi
   else
      return 1
   fi
   return 0
}
__registerFunction __gnustatCheck

# private
# check for gnu readlink
# called by:
# __dependencyCheck
# __getCanonicalPath
__gnureadlinkCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   # For this framework it is important to work with a gnu readlink, so:
   # special check for gnu readlink with "-f" gnu feature:
   if command -v readlink >/dev/null 2>&1; then
      readlink -f / 2>/dev/null 1>&2
      if (( $? != 0 )); then
         return 1
      fi
   else
      return 1
   fi
   return 0
}
__registerFunction __gnureadlinkCheck

# private
# Script: stacktrace / Interactive: help
# called by:
# every funtion that throws an exception
if [[ ! -z "$PS1" ]]; then
   __handleErrorMessage() {
      __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
      if [[ "$(Boolean.parseBoolean "${__HELP__}")" == "$(Boolean.TRUE)" ]]; then
         local printStream=err
         local class="$1"
         local func="$2"
         ${class}.help ${func}
      fi
      return 0
   }
else
   __handleErrorMessage() {
      if [[ "$(Boolean.parseBoolean "${__STACKTRACE__}")" == "$(Boolean.TRUE)" ]]; then
         __stacktrace
      fi
      return 0
   }
fi
__registerFunction __handleErrorMessage

# private
# prints or prints not the traceback header to stderr
# called by:
# __throw
__tracebackHeader() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   if [[ $(Boolean.parseBoolean "$__STACKTRACE__") == "$(Boolean.TRUE)" ]] && [[ -z "$PS1" ]];  then
      System.err.println "Traceback (most recent call first):"
   fi
   return 0
}
__registerFunction __tracebackHeader

# private 
# generates stacktrace
# called by:
# __handleErrorMessage
__stacktrace() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   declare -i i=1
   until [[ "${FUNCNAME[$i]}" = "main" ]]
   do
      if (( $i == 1 )); then
         System.err.println "   File \"${BASH_SOURCE[$i+1]}\", line $((${BASH_LINENO[$i]}-2)), in ${FUNCNAME[$i+1]}"
      else
         System.err.println "   File \"${BASH_SOURCE[$i+1]}\", line ${BASH_LINENO[$i]}, in ${FUNCNAME[$i+1]}, calling ${FUNCNAME[$i]}"
      fi
      ((i++))
   done
   declare -i pid=${BASHPID}
   local unsetAtEnd=$(Boolean.FALSE)
   # is extglob set ?
   shopt -q extglob
   # if extglob not set already --> set it now and change boolean
   if (( $? == 1 )); then
      shopt -s extglob
      unsetAtEnd=$(Boolean.TRUE)
   fi 
   if [[ "$(uname -s 2>/dev/null)" == "Linux" ]]; then
      declare -i index=0
      declare -a status
      while (( $pid >= 1 ))
      do
         mapfile status </proc/$pid/status
         until [[ ${status[$index]:0:4} == "PPid" ]]
         do
            ((index++))
         done
         command=$(</proc/$pid/cmdline)
         System.err.println "   Process ${command}, pid ${pid}"
         pid=${status[$index]/PPid:/}
      done
   elif  [[ "$(uname -s 2>/dev/null)" == CYGWIN_NT-* ]]; then
      declare -i index=0
      declare -a status
      while (( $pid > 1 ))
      do
         mapfile status </proc/$pid/status
         until [[ ${status[$index]:0:4} == "PPid" ]]
         do
            ((index++))
         done
         command=$(</proc/$pid/cmdline)
         System.err.println "   Process ${command}, pid ${pid}"
         pid=${status[$index]/PPid:/}
      done
   else
      if command -v ps 2>&1 1>/dev/null; then
         local process showpid
         while (( $pid >= 1 ))
         do
            process="$(ps -p $pid -o command="" 2>/dev/null 2>/dev/null)"
            showpid="$(ps -p $pid -o pid="" 2>/dev/null 2>/dev/null)"
            System.out.print "   Process ${process##+([[:space:]])}"
            System.out.println ", pid ${showpid##+([[:space:]])}"               
            pid=$(ps -p "${pid}"  -o ppid="" 2>/dev/null 2>/dev/null)
         done
      fi
   fi
   if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
      shopt -u extglob
   fi 
   return $returnValue
}
__registerFunction __stacktrace

# private
# checks if given parameter is an associative array
# called by:
# oobash.source during sourcetime
__isAssocArray() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local tmp="$(declare -p "$1" 2>/dev/null)"
   tmp="${tmp/declare -/}"
   if [[ "${tmp:0:1}" == "A" ]]; then
      return 0
   else
      return 1
   fi
}
__registerFunction __isAssocArray

# private
# strips double and trailing "/" characters in given path
# called by:
# __dirname
# __basename
# File constructor
__stripPath() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"

   local path="$1"
   # empty --> nothing to do
   if [[ -z "${path}" ]]; then
      System.out.println ""
      return 0
   fi

   # Strip trailing '/' characters from path
   local tmppath=''
   while [[ "${tmppath}" != "${path}" ]]
   do
      tmppath="${path}"
      path="${tmppath%/}"
   done

   # now empty --> only "/" characters --> path is "/"
   if [[ -z "${path}" ]]; then
      System.out.println "/"
      return 0
   fi

   # Strip double '/' characters from path
   tmppath=''
   local lastchar=''
   local char
   for ((i=0; i < ${#path}; i++))
   do
      char="${path:i:1}"
      if [[ "${lastchar}" != "/" ]]; then
         tmppath="${tmppath}""${char}"
      else
         if [[ "${char}" != "${lastchar}" ]]; then
            tmppath="${tmppath}""${char}"
         fi
      fi
      lastchar=${char}
   done
   path="${tmppath}"
   System.out.println "${path}"
   return 0
}
__registerFunction __stripPath

# extglob has to be set, to be able to source __isBashInteger without errors
declare unsetAtEnd
shopt -q extglob
# if extglob not set already --> set it now and change boolean 
if (( $? == 1 )); then
   shopt -s extglob
   unsetAtEnd="true"
fi

# private
# check for integer input
# called by:
# __setLastModified
# __setPriority
# __zfill
# __center
# __lastIndexOf
# __indexOf
# __charAt
# __substring
# __getLine
# __delLine
# __replaceLine
# __insertBeforeLine
# __insertAfterLine
# __startsWith
# System.exit
# Ssh
# Process
__isBashInteger() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local unsetAtEnd
   shopt -q extglob
   # if extglob not set already --> set it now and change boolean 
   if (( $? == 1 )); then
      shopt -s extglob
      unsetAtEnd="$(Boolean.TRUE)"
   fi

   local bool="$(Boolean.FALSE)"

   case "$1" in
      ?([+-])+([[:digit:]]) )
         declare value1="$1"
         declare -i value2="$1"
         # check for max int size
         if [[ "${value1}" == "${value2}" || "${value1}" == "+""${value2}" || "${value1}" == "-0" ]]; then
            bool="$(Boolean.TRUE)"
         fi
         ;;
   esac

   if [[ "$(Boolean.parseBoolean "$unsetAtEnd")" == "$(Boolean.TRUE)" ]]; then
      shopt -u extglob
   fi

   if [[ "$(Boolean.parseBoolean "$bool")" == "$(Boolean.TRUE)" ]]; then
      return 0
   else
      return 1
   fi
}
__registerFunction __isBashInteger

if [[ "${unsetAtEnd}" == "true" ]]; then
   shopt -u extglob
fi
unset unsetAtEnd

# private
# returns the local date format
# called by:
# Script.generator
# Class.generator
__localDateFormat() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local format
   case $LANG in
      en_US*|en_BZ*)
         format="+%m/%d/%Y"
         ;;
      zh_CN*|ko_KR*|fa_IR*|ja_JP*|hu_HU*|lt_LT*)
         format="+%Y-%m-%d"
         ;;
      *)
         format="+%d.%m.%Y"
         ;;
   esac
   System.out.println "${format}"
   return 0
}
__registerFunction __localDateFormat

# private
# checks if a given file descriptor refers to a terminal
# possible arguments: integer of file descriptor or the strings: STDIN, STDOUT, STDERR
# called by:
# Class.generator
# Man.generator
# Script.generator
__isatty() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i FD
   declare -u arg="$1"
   if __isBashInteger "${arg}"; then
      FD="${arg}"
   else
      case "${arg}" in
         STDIN)  FD=0
         ;;
         STDOUT) FD=1
         ;;
         STDERR) FD=2
         ;;
         *) return 1
         ;;
      esac
   fi
   
   if [[ -t ${FD} ]]; then
      return 0
   else
      return 1
   fi
}
__registerFunction __isatty

# private
# returns the charcter code of first etter of given string 
# called by:
# __charCodeAt (Sting)
# __compareToIgnoreCase (String)
# __isLowerCase (String)
# __isUpperCase (String)
# __compareTo (Comparable)
# __hashCode (Object)
# __strLower (Private)
# __strUpper (Private)
__charCode() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local char="${1:0:1}"
   declare -i code
   code=$(printf '%d\n' "'$char")
   System.out.println "${code}" 
   return 0
}
__registerFunction __charCode

# private
# check for log4oobash.properties file in the same directory
# from where this file gets sourced
# called by:
# every time you source this framework by oobash.source
__lookForLoggingPropertiesFile() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local call="${1/[0-9]* /}"
   if [[ "${call}" != "NULL" ]]; then
      local directory="$(__dirname "${call}" 2>/dev/null)"
      local base="$(__getFileBase "${call}" 2>/dev/null)"
      local filebase="$(__basename "${base}")"
      local logfile="log4-"${filebase}".properties"
      if [[ -r "${directory}"/"${logfile}" ]]; then
         return 0
      fi
   fi
   return 1
}
__registerFunction __lookForLoggingPropertiesFile

# private
# asks local terminal database if this terminal supports colours
# called by:
__terminalSupportsColors() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=1
   if command -v tput >/dev/null 2>&1; then
      declare -i numberOfColors=$(tput colors 2>/dev/null)
      if (( $numberOfColors >= 8 )); then
         returnValue=0
      fi
   fi
   return $returnValue
}
__registerFunction __terminalSupportsColors

# private
# returns a timestamp (for a logevent)
# called by:
if command -v date 2>&1 1>/dev/null; then
   __getLoggingTimestamp() {
      date "+${LOG_DATE_PATTERN}"
      return 0
   }
else
   __getLoggingTimestamp() {
      System.out.println "$SECONDS sec"
      return 0
   }
fi
__registerFunction __getLoggingTimestamp

# private
# checks if BASH_XTRACEFD is available with this bash version
# called by:
# all oobash scripts if in logging trace mode
__isXTRACEFDAvailable() {
   if (( ${BASH_VERSINFO[1]} != 0 )); then
      return 0
   else
      return 1
   fi
}
__registerFunction __isXTRACEFDAvailable

# private
# tries to return a free file descriptor
# called by:
# all oobash scripts if in logging trace mode
__getFreeFD() {
   declare -i returnValue=0
   shopt -q extglob
   if (( $? == 1 )); then
      shopt -s extglob
      unsetAtEnd=$(Boolean.TRUE)
   fi
   declare -i freeFD=0
   declare -i maxFDCount
   maxFDCount=$(ulimit -n)

   if [[ "$(uname -s 2>/dev/null)" == "Linux" ]]; then
      while [[ -e /proc/$$/fd/${freeFD} ]] && (( ${freeFD} < ${maxFDCount} ))
      do
         ((freeFD++))
      done
   else
      if command -v lsof >/dev/null 2>&1; then
         declare -i i
         local bool fd
         for ((freeFD=0; freeFD < ${maxFDCount}; freeFD++))
         do
            bool="$(Boolean.TRUE)"
            for fd in $(lsof -p $$ -F f)
            do
               if [[ "$fd" == f* ]]; then
                  fd="${fd:1}"
                  if [[ -z "${fd##+([[:digit:]])}" ]]; then
                     if (( $fd == $freeFD)); then
                        bool="$(Boolean.FALSE)"
                        break
                     fi
                  fi
               fi
            done
            if [[ "$(Boolean.parseBoolean "$bool")" == "$(Boolean.TRUE)" ]]; then
               break
            fi
         done
      else
         returnValue=1
      fi
   fi

   # You will recognize this problem much earlier... ;-)
   if (( freeFD == maxFDCount )); then
      returnValue=1
   fi

   if (( $returnValue == 0 )); then
      System.out.println ${freeFD}
   fi

   if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
      shopt -u extglob
   fi
   return $returnValue
}
__registerFunction __getFreeFD

# private
# returns PS4 indentation depending on the level of indirection.
# called by:
# PS4
__ps4IndirectionLevelIndentation() {
   local indentation=""
   for ((i=0;i<$((${BASH_SUBSHELL}));i++))
   do 
      indentation="${indentation}  "
   done
   System.out.print "${indentation}"
   return 0
}
__registerFunction __ps4IndirectionLevelIndentation

# private
# sets PS4 prompt for a better prefix during tracing output
# possible argument: if needed an own ps4 prefix
# called by:
# all oobash scripts if in trace mode
__setPS4() {
   local ps4=${1:-' $(__ps4IndirectionLevelIndentation)Running ${SECONDS} sec:${BASH_SOURCE##*/}:${LINENO}:${FUNCNAME[0]}(): '}
   export PS4="$ps4"
   return 0
}
__registerFunction __setPS4

# private
# good enough to sort some words
# possible argument: words to sort
# called by:
# toString
# Class.generator
__wordSort() {
   declare -a array=("$@")
   declare -i j i
   local temp word result=''
   for (( i=${#array[@]}-1; i>0; i-- )); do
      for (( j=1; j<=i; j++ )); do
         if [[ "${array[j-1]}" == "${array[j]}" ]] ||\
            [[ "${array[j-1]}" <  "${array[j]}" ]] ; then
            continue
         fi
         temp="${array[j]}"
         array[j]="${array[j-1]}"
         array[j-1]="$temp"
      done
   done
   for word in "${array[@]}"
   do
      result+="${word} "
   done
   System.out.println "${result}"
}
__registerFunction __wordSort

##########
# UNUSED #
##########

# private
# returns the value of a given attribute of a given object
__getAttributeFromObjectByName() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   local this="$1"
   local attribute="$2"
   local pointer
   pointer="$(__getObjectPointer "${this}")"
   System.out.println "${__ATTRIBUTEPOOL__[${pointer}@${attribute}]}"
   return $returnValue
}
__registerFunction __getAttributeFromObjectByName

# private
# checks if given parameter is writeable
__isWriteable() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local tmp
   tmp="$(declare -p "$1" 2>/dev/null)"
   if (( $? == 0 )); then
      tmp="${tmp/declare -/}"
      declare -i i
      local char
      for ((i=0; i < ${#tmp}; i++))
      do
         char="${tmp:i:1}"
         case "${char}" in
            "r") return 1;;
            " ") return 0;;
         esac
      done
   else
      return 1
   fi
}
__registerFunction __isWriteable

# private
# checks if given parameter is an array
__isArray() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local tmp="$(declare -p "$1" 2>/dev/null)"
   tmp="${tmp/declare -/}"
   if [[ "${tmp:0:1}" == "a" ]]; then
      return 0
   else
      return 1
   fi
}
__registerFunction __isArray
