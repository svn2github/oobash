##################################################################
# Author:  andreas.gregor.frank@googlemail.com                                
#
# License: The MIT License
#
# Copyright (c) <2010> <andreas.gregor.frank@googlemail.com>

###################
###################
##               ##
##     STRING    ## 
##               ##
###################
###################


#########################
#                       #
#      CONSTRUCTOR      # 
#                       #
#########################



String() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"

   local this="$1"
   local string="$2"
   local class="${FUNCNAME}"
   local func="${FUNCNAME}"

   if (( $# != 2 )); then
      __throw "IllegalArgumentException" ": Wrong number of arguments $#"
      return $?
   fi

   __isObjectnameValid "${FUNCNAME}" || return $?

   local pointer=$((__OBJCOUNTER__++))


   __destruct "${this}"

   __alias "${this}" "${FUNCNAME}"

   __attribute string "${string}" 

   return 0
}
__registerClass String

##################
#                #
#     STATICS    #
#                #
##################

String.asciiLetters() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"

   local class="String"
   local func="${FUNCNAME}"

   if (( $# != 0 )); then
      __throw "IllegalArgumentException" ": Wrong number of arguments $#" || return $?
   fi

   System.out.println 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

   return 0
}
__registerFunction String.asciiLetters

String.asciiLettersLowerCase() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"

   local class="String"
   local func="${FUNCNAME}"

   if (( $# != 0 )); then
      __throw "IllegalArgumentException" ": Wrong number of arguments $#" || return $?
   fi

   System.out.println 'abcdefghijklmnopqrstuvwxyz'

   return 0
}
__registerFunction String.asciiLettersLowerCase

String.asciiLettersUpperCase() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"

   local class="String"
   local func="${FUNCNAME}"

   if (( $# != 0 )); then
      __throw "IllegalArgumentException" ": Wrong number of arguments $#" || return $?
   fi

   System.out.println 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

   return 0
}
__registerFunction String.asciiLettersUpperCase

String.digits() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"

   local class="String"
   local func="${FUNCNAME}"

   if (( $# != 0 )); then
      __throw "IllegalArgumentException" ": Wrong number of arguments $#" || return $?
   fi

   System.out.println '0123456789'

   return 0
}
__registerFunction String.digits

if (( ${BASH_VERSINFO[1]} >= 2 )); then
   String.fromCharCode() {
      __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"

      local class="String"
      local func="${FUNCNAME}"
      local hexValue
      local result=""

      if (( $# == 0 )); then
         __throw "IllegalArgumentException" ": Wrong number of arguments 0" || return $?
      fi

      while (($#))
      do
         if ! __isBashInteger "$1"; then
            __throw "IllegalArgumentException" ": Illegal argument: \"$1\"" || return $?
         fi

         if (( "$1" < 0 )) || (( "$1" > 65535 )); then
            __throw "IllegalArgumentException" ": Illegal argument: \"$1\"" || return $?
         fi

         case $1 in
            10)  result+="
"
            ;;
            # 128 to 159 (x0080 - x009F) are not printable ("C1 control codes")
            160) result+=" ";;
            161) result+=¡;;
            162) result+=¢;;
            163) result+=£;;
            164) result+=¤;;
            165) result+=¥;;
            166) result+=¦;;
            167) result+=§;;
            168) result+=¨;;
            169) result+=©;;
            170) result+=ª;;
            171) result+=«;;
            172) result+=¬;;
            # http://www.cs.tut.fi/~jkorpela/shy.html
            # --> ??? for soft hyphen:
            173) result+=-;;
            174) result+=®;;
            175) result+=¯;;
            176) result+=°;;
            177) result+=±;;
            178) result+=²;;
            179) result+=³;;
            180) result+=´;;
            181) result+=µ;;
            182) result+=¶;;
            183) result+=·;;
            184) result+=¸;;
            185) result+=¹;;
            186) result+=º;;
            187) result+=»;;
            188) result+=¼;;
            189) result+=½;;
            190) result+=¾;;
            191) result+=¿;;
            192) result+=À;;
            193) result+=Á;;
            194) result+=Â;;
            195) result+=Ã;;
            196) result+=Ä;;
            197) result+=Å;;
            198) result+=Æ;;
            199) result+=Ç;;
            200) result+=È;;
            201) result+=É;;
            202) result+=Ê;;
            203) result+=Ë;;
            204) result+=Ì;;
            205) result+=Í;;
            206) result+=Î;;
            207) result+=Ï;;
            208) result+=Ð;;
            209) result+=Ñ;;
            210) result+=Ò;;
            211) result+=Ó;;
            212) result+=Ô;;
            213) result+=Õ;;
            214) result+=Ö;;
            215) result+=×;;
            216) result+=Ø;;
            217) result+=Ù;;
            218) result+=Ú;;
            219) result+=Û;;
            220) result+=Ü;;
            221) result+=Ý;;
            222) result+=Þ;;
            223) result+=ß;;
            224) result+=à;;
            225) result+=á;;
            226) result+=â;;
            227) result+=ã;;
            228) result+=ä;;
            229) result+=å;;
            230) result+=æ;;
            231) result+=ç;;
            232) result+=è;;
            233) result+=é;;
            234) result+=ê;;
            235) result+=ë;;
            236) result+=ì;;
            237) result+=í;;
            238) result+=î;;
            239) result+=ï;;
            240) result+=ð;;
            241) result+=ñ;;
            242) result+=ò;;
            243) result+=ó;;
            244) result+=ô;;
            245) result+=õ;;
            246) result+=ö;;
            247) result+=÷;;
            248) result+=ø;;
            249) result+=ù;;
            250) result+=ú;;
            251) result+=û;;
            252) result+=ü;;
            253) result+=ý;;
            254) result+=þ;;
            255) result+=ÿ;;
            *)
               hexValue=$(printf %x "$1")
               result+="$(printf "%b" "\u${hexValue}")";;
         esac
         shift
      done

      System.out.println "${result}"

      return 0
   }
   __registerFunction String.fromCharCode
fi

String.hexDigits() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"

   local class="String"
   local func="${FUNCNAME}"

   if (( $# != 0 )); then
      __throw "IllegalArgumentException" ": Wrong number of arguments $#" || return $?
   fi

   System.out.println '0123456789abcdefABCDEF'

   return 0
}
__registerFunction String.hexDigits

String.octDigits() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"

   local class="String"
   local func="${FUNCNAME}"

   if (( $# != 0 )); then
      __throw "IllegalArgumentException" ": Wrong number of arguments $#" || return 0
   fi

   System.out.println '01234567'

   return 0
}
__registerFunction String.octDigits


#####################
#                   #
#      METHODS      # 
#                   #
#####################

__base64Decode() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      if command -v openssl >/dev/null 2>&1; then
         local output input
         input="$("$this".toString)"
         output="$(System.out.println "${input}" | openssl enc -base64 -d 2>/dev/null)"
         if (( "${#input}" != 0 && "${#output}" == 0 )); then
            __throw "DecoderException" ": Decoding problem with: ""'${input}'"" "
            returnValue=$?
            __handleErrorMessage "$2" "${FUNCNAME:2}"
         else
            System.out.println "${output}"
         fi
      else
         __throw "NotInPathException" ": openssl not in path"
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__base64Encode() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      if command -v openssl >/dev/null 2>&1; then
         local output
         local input
         input="$("$this".toString)"
         output="$(System.out.print "${input}" | openssl enc -base64 2>/dev/null)"
         System.out.println "${output}"
      else
         __throw "NotInPathException" ": openssl not in path"
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__capitalize() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toLowerCase)"
      local firstchar="${str:0:1}"
      firstchar="$(__strUpper "${firstchar}")"
      System.out.println "${firstchar}""${str:1}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__center() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      local this="$1"
      if ! __isBashInteger "$3"; then
         __throw "IllegalArgumentException" ": Illegal argument: \"$3\""
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
      else
         declare -i width=$3
         if (( $("$this".length) < $width )); then
            declare -i spaces=$width-$("$this".length)
            declare -i lspaces=$spaces/2
            declare -i rspaces=$spaces-$lspaces
            declare -i lruns=0
            declare -i rruns=0
            declare left=''
            declare right=''
            while (( $lruns < $lspaces ))
            do
               left+=' '
               lruns+=1
            done
            while (( $rruns < $rspaces ))
            do
               right+=' '
               rruns+=1
            done
            System.out.println  "$left""$("$this".toString)""$right"
         else
            System.out.println "$("$this".toString)"
         fi
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__charAt() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      this="$1"
      if ! __isBashInteger "$3"; then
         __throw "IllegalArgumentException" ": Illegal argument: \"$3\""
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
      else
         declare -i pos="$3"
         if  (( $pos <= ($("$this".length)-1) )) && (( $pos >= 0 )); then
            local str="$("$this".toString)"
            local char=${str:$pos:1}
            System.out.println "${char}"
         else
            __throw "IndexOutOfBoundsException" ": String index out of range: $pos"
            returnValue=$?
            __handleErrorMessage "$2" "${FUNCNAME:2}"
         fi
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__charCodeAt() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      this="$1"
      if ! __isBashInteger "$3"; then
         __throw "IllegalArgumentException" ": Illegal argument: \"$3\""
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
      else
         declare -i pos="$3"
         if  (( $pos <= ($("$this".length)-1) )) && (( $pos >= 0 )); then
            local str="$("$this".toString)"
            local char=${str:$pos:1}
            declare -i code=$(__charCode "${char}")
            # this is NOT the null character, but an error
            if (( $code == 0 )); then
               __throw "IllegalArgumentException" ": Invalid character at index ${pos}"
               returnValue=$?
               __handleErrorMessage "$2" "${FUNCNAME:2}"
            else
               System.out.println "${code}"
            fi
         else
            __throw "IndexOutOfBoundsException" ": String index out of range: ${pos}"
            returnValue=$?
            __handleErrorMessage "$2" "${FUNCNAME:2}"
         fi
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__compareToIgnoreCase() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      local this="$1"
      local str1="$("$this".toUpperCase)"
      local str2="$(__strUpper "$3")"
      declare -i result
      if [[ "$str1" == "$str2" ]]; then
         result=0
      else
         declare -i length=-1
         if (( ${#str1} == ${#str2} )); then
            length=${#str2}
         fi
         if (( $length == -1 )); then
            result=$((${#str1}-${#str2}))
            if (( ${#str1} < ${#str} )); then
               length=${#str1}
            else
               length=${#str2}
            fi
         fi	
         declare -i i=0
         local charStr1 charStr2
         declare -i valueStr1 valueStr2
         for ((i=0; i < $length; i++))
         do
            charStr1="${str1:i:1}"
            valueStr1=$(__charCode "${charStr1}")
            charStr2="${str2:i:1}"
            valueStr2=$(__charCode "${charStr2}")
            if (( ${valueStr1} != ${valueStr2} )); then
               result=$((valueStr1-valueStr2))
               break
            fi		
         done
      fi
      System.out.println "${result}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__concat() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      local this="$1"
      local str="$("$this".toString)"
      System.out.println "$str""$3"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__contains() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      local this="$1"
      local var="$3"
      local str="$("$this".toString)"
      if [[ "$str" != "${str/"$var"/}" ]]; then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__containsNone() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      local this="$1"
      local var="$3"
      local str="$("$this".toString)"
      local char
      local bool="$(Boolean.TRUE)"
      for ((i=0; i < ${#var}; i++))
      do
         char="${var:i:1}"
         if [[ "$str" != "${str/"$char"/}" ]]; then
            bool="$(Boolean.FALSE)"
            break
         fi
      done
      Boolean.parseBoolean "${bool}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__containsOnly() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      local this="$1"
      local var="$3"
      local str="$("$this".toString)"
      local char
      local bool="$(Boolean.TRUE)"
      for ((i=0; i < ${#str}; i++))
      do
         char="${str:i:1}"
         if [[ "$var" == "${var/"$char"/}" ]]; then
            bool="$(Boolean.FALSE)"
            break
         fi
      done
      Boolean.parseBoolean "${bool}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__count() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      local this="$1"
      local pattern="$3"
      local replaced="$("$this".replaceAll "$pattern" "")"
      declare -i patternLength=${#pattern}
      declare -i replacedLength=${#replaced}
      declare -i stringLength=$("$this".length)
      if (( $patternLength == 0 )); then
         System.out.println $(( $("$this".length) + 1 ))
      else
         if command -v bc >/dev/null 2>&1; then
            declare -i count=$(bc <<< "($stringLength-$replacedLength)/$patternLength")
            System.out.println "${count}"
         else
            __throw "NotInPathException" ": bc not in path"
            returnValue=$?
            __handleErrorMessage "$2" "${FUNCNAME:2}"
         fi
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__endsWith() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      local this="$1"
      local endstring="$3"
      local str="$("$this".toString)"
      if [[ "$str" == *"$endstring" ]]; then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__equalsIgnoreCase() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      local this="$1"
      local argobject="$3"
      local argclass
      argclass="$("$argobject".getClass 2>/dev/null)"
      if (( $? == 0 )); then
         if [[ "$("$this".getClass)" == "$argclass" ]]; then
            if [[ "$("$argobject".toUpperCase)" == "$("$this".toUpperCase)" ]]; then
               Boolean.TRUE
            else
               Boolean.FALSE
            fi
         else
            __throw "WrongClassException" ": Illegal argument: \"${argobject}\": $("$argobject".getClass)"
            returnValue=$?
            __handleErrorMessage "$2" "${FUNCNAME:2}"
         fi
      else
         __throw "IllegalArgumentException" ": Illegal argument: \"$3\" is no object"
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__indexOf() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   case $# in
      3) local pattern="$3"
         declare -i from=0;;
      4) local pattern="$3"
         if ! __isBashInteger "$4"; then
            __throw "IllegalArgumentException" ": Illegal argument: \"$4\""
            returnValue=$?
            __handleErrorMessage "$2" "${FUNCNAME:2}"
            return $returnValue
         fi
         declare -i from=$4
         # negative index ?
         if (( 0 > $4 )); then
            from=0
         fi;;
      *) __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
         return $returnValue;;
   esac
   local this="$1"
   declare -i patternLength=${#pattern}
   local str="$("$this".toString)"
   str="${str:$from}"
   declare -i strlength=${#str}
   local newstr="${str%%$pattern*}"
   declare -i newstrlength=${#newstr}
   # Java API:
   # k >= Math.min(fromIndex, str.length()) && this.startsWith(str, k)
   # --> looking for empty string '' out of index returns stringlength instead of -1
   if (( $patternLength == 0 )); then
      if (( $from <= $("$this".length) )); then
         System.out.println $from
      else
         System.out.println $("$this".length)
      fi
      return $returnValue
   fi
   if (( $strlength == $newstrlength )); then
      System.out.println -1
   else
      System.out.println $(($newstrlength+$from))
   fi
   return $returnValue
}

__indexOfDifference() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      local this="$1"
      local str1="$("$this".toString)"
      local str2="$3"
      declare -i maxindex
      if (( ${#str1} < ${#str2} )); then
         maxindex=${#str2}
      else
         maxindex=${#str1}
      fi
      local char1 char2
      declare -i index=-1
      for ((i=0; i < $maxindex; i++))
      do
         char1="${str1:i:1}"
         char2="${str2:i:1}"
         if [[ "${char1}" != "${char2}" ]]; then
            index=$i
            break
         fi
      done
      System.out.println "${index}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__isAlnum() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      shopt -s extglob
      if [[ "$("$this".isEmpty)" == $(Boolean.FALSE) ]]; then
         if [[ "${str##+([[:alnum:]])}" == "" ]]; then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
      else
         Boolean.FALSE
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__isAlpha() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      shopt -s extglob
      local str="$("$this".toString)"
      if [[ "$("$this".isEmpty)" == $(Boolean.FALSE) ]]; then
         if [[ "${str##+([[:alpha:]])}" == "" ]]; then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
      else
         Boolean.FALSE
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__isAscii() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      shopt -s extglob
      local str="$("$this".toString)"
      if [[ "$("$this".isEmpty)" == $(Boolean.FALSE) ]]; then
         if [[ "${str##+([[:ascii:]])}" == "" ]]; then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
      else
         Boolean.FALSE
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__isDigit() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      shopt -s extglob
      if [[ "$("$this".isEmpty)" == $(Boolean.FALSE) ]]; then
         if [[ "${str##+([[:digit:]])}" == "" ]]; then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
      else
         Boolean.FALSE
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__isEmpty() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      declare -i length=$("$this".length)
      if (( $length == 0 )); then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__isHexDigit() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      shopt -s extglob
      if [[ "$("$this".isEmpty)" == $(Boolean.FALSE) ]]; then
         if [[ "${str##+([[:xdigit:]])}" == "" ]]; then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
      else
         Boolean.FALSE
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__isLowerCase() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      local lower=$(Boolean.FALSE)
      declare -i i=0
      local char valueOf
      for ((i=0; i < ${#str}; i++))
      do
         char="${str:i:1}"
         valueOf=$(__charCode "$char")
         case ${valueOf} in
            # upper case us ascii + german umlauts + franch + polish +
            # spanish + romanian + czech + slovak + slovenian + slovenian +
            # swedish + finnish + danish + norwegian + scottish gaelic + catalan +
            # hungarian + icelandic special characters + uppercase sharp s + cyrillic characters
            65|66|67|68|69|70|71|72|73|74|75|76|77|78|79|\
            80|81|82|83|84|85|86|87|88|89|90|196|214|220|\
            140|192|194|198|199|200|201|202|203|206|207|212|\
            217|219|260|280|211|262|321|323|346|377|379|193|\
            205|209|218|258|350|354|536|538|381|352|344|340|\
            327|313|268|221|366|282|270|356|216|197|336|368|\
            204|210|208|222|7838|\
            1024|1025|1026|1027|1028|1029|1030|1031|\
            1032|1033|1034|1035|1036|1037|1038|1039|\
            1040|1041|1042|1043|1044|1045|1046|1047|\
            1048|1049|1050|1051|1052|1053|1054|1055|\
            1056|1057|1058|1059|1060|1061|1062|1063|\
            1064|1065|1066|1067|1068|1069|1070|1071)
               lower=$(Boolean.FALSE)
               break;;
            # lower case us ascii + german umlauts + franch + polish +
            # spanish + romanian + czech + slovak + slovenian + slovenian +
            # swedish + finnish + danish + nowegian + scottish gaelic + catalan +
            # hungarian + icelandic special characters + cyrillic characters
            97|98|99|100|101|102|103|104|105|106|107|108|\
            109|110|111|112|113|114|115|116|117|118|119|120|\
            121|122|223|228|246|252|156|224|226|230|231|232|\
            233|234|235|238|239|244|249|251|261|281|243|263|\
            322|324|347|378|380|225|237|241|250|259|351|355|\
            537|539|382|353|345|341|328|314|269|253|367|283|\
            271|357|248|229|337|369|236|242|240|254|\
            1072|1073|1074|1075|1076|1077|1078|1079|\
            1080|1081|1082|1083|1084|1085|1086|1087|\
            1088|1089|1090|1091|1092|1093|1094|1095|\
            1096|1097|1098|1099|1100|1101|1102|1103|\
            1104|1105|1106|1107|1108|1109|1110|1111|\
            1112|1113|1114|1115|1116|1117|1118|1119)
               lower=$(Boolean.TRUE);;
         esac
      done
      System.out.println "${lower}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__isPrintable() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      shopt -s extglob
      if [[ "$("$this".isEmpty)" == $(Boolean.FALSE) ]]; then
         if [[ "${str##+([[:print:]])}" == "" ]]; then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
      else
         Boolean.FALSE
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__isSpace() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      shopt -s extglob
      if [[ "$("$this".isEmpty)" == $(Boolean.FALSE) ]]; then
         if [[ "${str##+([[:space:]])}" == "" ]]; then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
      else
         Boolean.FALSE
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__isTitle() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      if [[ "$("$this".toLowerCase)" == "$("$this".toUpperCase)" ]]; then
         Boolean.FALSE
      else
         if [[ "$("$this".title)" == "$("$this".toString)" ]]; then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__isUpperCase() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      local upper=$(Boolean.FALSE)
      declare -i i=0
      local char valueOf
      for ((i=0; i < ${#str}; i++))
      do
         char="${str:i:1}"
         valueOf=$(__charCode "$char")
         case ${valueOf} in
            # upper case us ascii + german umlauts + franch + polish +
            # spanish + romanian + czech + slovak + slovenian + slovenian +
            # swedish + finnish + danish + norwegian + scottish gaelic + catalan +
            # hungarian + icelandic special characters + uppercase sharp s + cyrillic characters
            65|66|67|68|69|70|71|72|73|74|75|76|77|78|79|\
            80|81|82|83|84|85|86|87|88|89|90|196|214|220|\
            140|192|194|198|199|200|201|202|203|206|207|212|\
            217|219|260|280|211|262|321|323|346|377|379|193|\
            205|209|218|258|350|354|536|538|381|352|344|340|\
            327|313|268|221|366|282|270|356|216|197|336|368|\
            204|210|208|222|7838|\
            1024|1025|1026|1027|1028|1029|1030|1031|\
            1032|1033|1034|1035|1036|1037|1038|1039|\
            1040|1041|1042|1043|1044|1045|1046|1047|\
            1048|1049|1050|1051|1052|1053|1054|1055|\
            1056|1057|1058|1059|1060|1061|1062|1063|\
            1064|1065|1066|1067|1068|1069|1070|1071)
               upper=$(Boolean.TRUE);;
            # lower case us ascii + german umlauts + franch + polish +
            # spanish + romanian + czech + slovak + slovenian + slovenian +
            # swedish + finnish + danish + nowegian + scottish gaelic + catalan +
            # hungarian + icelandic special characters + cyrillic characters
            97|98|99|100|101|102|103|104|105|106|107|108|\
            109|110|111|112|113|114|115|116|117|118|119|120|\
            121|122|223|228|246|252|156|224|226|230|231|232|\
            233|234|235|238|239|244|249|251|261|281|243|263|\
            322|324|347|378|380|225|237|241|250|259|351|355|\
            537|539|382|353|345|341|328|314|269|253|367|283|\
            271|357|248|229|337|369|236|242|240|254|\
            1072|1073|1074|1075|1076|1077|1078|1079|\
            1080|1081|1082|1083|1084|1085|1086|1087|\
            1088|1089|1090|1091|1092|1093|1094|1095|\
            1096|1097|1098|1099|1100|1101|1102|1103|\
            1104|1105|1106|1107|1108|1109|1110|1111|\
            1112|1113|1114|1115|1116|1117|1118|1119)
               upper=$(Boolean.FALSE)
               break;;
         esac
      done
      System.out.println "${upper}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__isVisible() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      __visibilityCheck "$str"
      if (( $? == 0 )); then
            Boolean.TRUE
         else
            Boolean.FALSE
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__lastIndexOf() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   local this="$1"
   case $# in
      3) local pattern="$3"
         declare -i to=$("$this".length);;
      4) local pattern="$3"
         if ! __isBashInteger "$4"; then
            __throw "IllegalArgumentException" ": Illegal argument: \"$4\""
            returnValue=$?
            __handleErrorMessage "$2" "${FUNCNAME:2}"
            return $returnValue
         fi
         declare -i to=$(($4+1))
         # negative index ?
         if (( 0 > $4 )); then
            System.out.println -1
            return $returnValue
         fi;;
      *) __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
         return $returnValue;;
   esac
   local str="$("$this".toString)"
   str="${str:0:$to}"
   shopt -s extglob
   local replaced="${str//*$pattern/}"
   declare -i patternLength=${#pattern}
   declare -i replacedLength=${#replaced}
   declare -i stringLength=${#str}
   declare -i lastindex=$(($stringLength-$replacedLength))
   # nothing modified --> no match --> no index
   if (( $replacedLength == $stringLength )); then
      System.out.println -1
      return $returnValue
   fi
   if (( $patternLength == 0 )) && (( $stringLength < $("$this".length) )); then
      patternLength=$patternLength+1
   fi
   # ok if match is existing and if no substring neccessary
   System.out.println $(($lastindex-$patternLength))
   return $returnValue
}

__length() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      System.out.println ${#str}
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__lstrip() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      shopt -s extglob
      # trimming...
      local result="${str##+([[:space:]])}"
      System.out.println "${result}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__matches() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      local this="$1"
      local regex="$3"
      shopt -s extglob
      if [[ "$("$this".toString)" =~ $regex ]]; then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__replaceAll() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 4 )); then
      local this="$1"
      local substring="$3"
      local replacement="$4"
      local str="$("$this".toString)"
      if [[ -z "${substring}" ]]; then
         declare -i i=0
         local result="${replacement}"
         for ((i=0; i < ${#str}; i++))
         do
            local char="${str:i:1}"
            result+="${char}""${replacement}"
         done
         System.out.println "${result}"
      else
         shopt -s extglob
         System.out.println "${str//$substring/$replacement}"
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__replaceFirst() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 4 )); then
      local this="$1"
      local substring="$3"
      local replacement="$4"
      local str="$("$this".toString)"
      if [[ -z "${substring}" ]]; then
         System.out.println "${replacement}""${str}"
      else
         shopt -s extglob
         System.out.println "${str/$substring/$replacement}"
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__reverse() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      local result=""
      declare -i index=$(($("$this".length)-1))
      declare -i i
      local char
      for ((i=$index; i >= 0; i--))
      do
         char="${str:i:1}"
         result+="${char}"
      done
      System.out.println "${result}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__rstrip() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      shopt -s extglob
      # trimming...
      result="${str%%+([[:space:]])}"
      System.out.println "${result}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__startsWith() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   case $# in
      3) declare -i toffset=0;;
      4) if ! __isBashInteger "$4"; then
            __throw "IllegalArgumentException" ": Illegal argument: \"$4\""
            returnValue=$?
            __handleErrorMessage "$2" "${FUNCNAME:2}"
         fi
         declare -i toffset=$4;;
      *) __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}";;
   esac
   if (( returnValue == 0 )); then
      local this="$1"
      declare -i length=$("$this".length)
      local sub
      sub="$("$this".substring ${toffset} $(($length-1)))"
      returnValue=$?
      if (( returnValue == 0 )); then
         if [[ "${sub}" == "$3"* ]]; then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
      fi
   fi
   return $returnValue
}

__substring() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   local this="$1"
   declare -i count=$("$this".length)
   case $# in
      3) declare -i endIndex=${count};;
      4) if ! __isBashInteger "$4"; then
            __throw "IllegalArgumentException" ": Illegal argument: \"$4\""
            returnValue=$?
            __handleErrorMessage "$2" "${FUNCNAME:2}"
            return $returnValue
         fi
         declare -i endIndex=$4;;
      *) __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
         return $returnValue;;
   esac

   if ! __isBashInteger "$3"; then
      __throw "IllegalArgumentException" ": Illegal argument: \"$3\""
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   else
      declare -i beginIndex=$3
      if (( ${beginIndex} < 0 )); then
         __throw "IndexOutOfBoundsException" ": String index out of range: $beginIndex"
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
      if (( ${endIndex} > ${count} )); then
         __throw "IndexOutOfBoundsException" ": String index out of range: $endIndex"
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
      if (( ${beginIndex} > ${endIndex} )); then
         __throw "IndexOutOfBoundsException" ": String index out of range: $(($endIndex-$beginIndex))"
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
      local str="$("$this".toString)"
      declare -i length=$((endIndex-beginIndex))
      System.out.println "${str:$beginIndex:$length}"
   fi
   return $returnValue
}

__swapCase() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      local swaped=''
      declare -i i=0
      local char
      for ((i=0; i < ${#str}; i++))
      do
         char="${str:i:1}"
         case $char in
            # small sharp s
            ß)
            swaped+="ẞ";;
            # big sharp s
            ẞ)
            swaped+="ß";;
            # ignore case
            *)
            swaped+="${char~}" ;;
         esac
      done
      System.out.println "${swaped}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}


__title() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toLowerCase)"
      local output="${str~}"
      # "${str~}" does not work with big sharp s --> let's loop ;-(
      # "${str~}" does not work with CYGWIN_NT
      local next="$(Boolean.TRUE)"
      local result=''
      local char
      for ((i=0; i < ${#output}; i++))
      do
         char="${output:i:1}"
         if [[ "${next}" == "$(Boolean.TRUE)" ]]; then
            char="$(__strUpper  "${char}")"         
         fi
         if [[ "$(__strUpper  "${char}")" == "$(__strLower  "${char}")" ]]; then
            next="$(Boolean.TRUE)"
         else
            next="$(Boolean.FALSE)"
         fi
         result+="${char}"
      done
      System.out.println "${result}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__toLowerCase() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      local lower="$(__strLower "${str}")"
      System.out.println "${lower}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__toUpperCase() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      local upper="$(__strUpper "${str}")" 
      System.out.println "${upper}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__trim() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local str="$("$this".toString)"
      shopt -s extglob
      # trimming...
      local result="${str##+([[:space:]])}"    
      result="${result%%+([[:space:]])}"
      System.out.println "${result}"
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

__zfill() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      local this="$1"
      if ! __isBashInteger "$3"; then
         __throw "IllegalArgumentException" ": Illegal argument: \"$3\""
         returnValue=$?
         __handleErrorMessage "$2" "${FUNCNAME:2}"
      else
         declare -i width=$3
         length=$("$this".length)
         if (( $length < $width )); then
            local left=$(($width-$("$this".length)))
            printf -v pad "%."${left}"d"
            System.out.println "${pad}""$("$this".toString)"
         else
            System.out.println "$("$this".toString)"
         fi
      fi
   else
      __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
      returnValue=$?
      __handleErrorMessage "$2" "${FUNCNAME:2}"
   fi
   return $returnValue
}

#################
#               #
#     HELP      # 
#               #
#################

complete -W  "$(echo ${__String__[@]}) all String digits asciiLetters asciiLettersLowerCase asciiLettersUpperCase hexDigits octDigits fromCharCode" String.help

String.help() {    
   local printStream=${printStream:-out}
   if (( $# == 0 )); then
      System."${printStream}".println "
      Usage: String.help all|methodname|constructor|static
      Available methods:
      -base64Decode -base64Encode -capitalize
      -center -charAt -charCodeAt -compareTo
      -compareToIgnoreCase -concat -contains
      -containsNone -containsOnly -count
      -endsWith -equals -equalsIgnoreCase
      -getClass -hashCode -indexOf
      -indexOfDifference -isAlnum -isAlpha
      -isAscii -isDigit -isEmpty
      -isHexDigit -isLowerCase -isPrintable
      -isSpace -isTitle -isUpperCase
      -isVisible -lastIndexOf -length
      -lstrip -matches -replaceAll
      -replaceFirst -reverse -rstrip
      -startsWith -substring -swapCase
      -title -toLowerCase -toString
      -toUpperCase -trim -zfill
      Constructor: 
      -String
      Statics:
      -String.asciiLetters -String.asciiLettersLowerCase
      -String.asciiLettersUpperCase -String.digits
      -String.fromCharCode -String.hexDigits
      -String.octDigits
               "
      return 0
   fi
   while (($#))
   do
      local match=$(Boolean.FALSE)  
      case $1 in
         String|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               String
                  Constructor for the String objects.
               Parameters:
                  objectname 
                  string
               Returns:
                  None
               Throws:
                  IllegalArgumentException - if number of arguments != 2
                                           - if objectname is not valid
                                           - if objectname is a keyword
                                           - if objectname contains full stop character
                                           - if objectname contains slash character
               Example:
                  String a teststring
            ";;& 
         String.asciiLetters|asciiLetters|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               String.asciiLetters
               Parameters:
                  None
               Returns:
                  The concatenation of the String.asciiLettersLowerCase and 
                  String.asciiLettersUpperCase. 
                  This value is not locale-dependent.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String.asciiLetters
                  >>>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ  
               ";;&
         String.asciiLettersLowerCase|asciiLettersLowerCase|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               String.asciiLettersLowerCase
               Parameters:
                  None
               Returns:
                  The lowercase letters 'abcdefghijklmnopqrstuvwxyz'. 
                  This value is not locale-dependent and will not change.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String.asciiLettersLowerCase
                  >>>abcdefghijklmnopqrstuvwxyz    
               ";;&
         String.asciiLettersUpperCase|asciiLettersUpperCase|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               String.asciiLettersUpperCase
               Parameters:
                  None
               Returns:
                  The uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. 
                  This value is not locale-dependent and will not change.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String.asciiLettersUpperCase
                  >>>ABCDEFGHIJKLMNOPQRSTUVWXYZ
               ";;&
          String.digits|digits|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               String.digits
               Parameters:
                  None
               Returns:
                  The string '0123456789'
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example
                  String.digits
                  >>>0123456789
               ";;&
         String.fromCharCode|fromCharCode|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               String.fromCharCode
                  This function is only available, if bash4 has at least minor version number 2.
                  Converts Unicode decimal values into characters
               Parameters:
                  Unicode values
               Returns:
                  Converted characters as a string.
               Throws:
                  IllegalArgumentException - if parameter is no unicode value
                                           - if number of arguments == 0
               Example:
                  String.fromCharCode 72 69 76 76 79
                  >>>HELLO 
                  String.fromCharCode  9601 9602 9603 9604 9605 9606 9607 9608
                  >>>▁▂▃▄▅▆▇█
               ";;&
         String.hexDigits|hexDigits|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               String.hexDigits
               Parameters:
                  None
               Returns:
                  The string '0123456789abcdefABCDEF' 
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String.hexDigits
                  >>>0123456789abcdefABCDEF 
               ";;&
         String.octDigits|octDigits|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               String.octDigits
               Parameters:
                  None
               Returns:
                  The string '01234567'
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String.octDigits
                  >>>01234567
               ";;&
         base64Decode|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               base64Decode
                  Decodes this base 64 encoded string.
                  Only works if encoded data is in
                  Privacy Enhanced Mail (PEM) format:
                  -line length is 64 characters
                  -newline character after 64 characters
                  (RFC 4648, section 3.1)
               Parameters:
                  None 
               Returns:
                  base64 decoded data
               Throws:
                  NotInPathException - if openssl not in path
                  DecoderException - if problem with decoding
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a YWJj
                  a.base64Decode
                  >>>abc  
            ";;&
         base64Encode|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               base64Encode
                  Encodes this string with base64.
                  Encoded data is in Privacy Enhanced Mail (PEM) format:
                  -line length is 64 characters
                  -newline character after 64 characters
                  (RFC 4648, section 3.1)
               Parameters:
                  None
               Returns:
                  base64 encoded data
               Throws:
                  NotInPathException - if openssl not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a abc
                  a.base64Encode
                  >>>YWJj
            ";;&
         capitalize|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               capitalize
                  Optimized for german, french, polish, spanish, romanian, czech, slovak, slovenian, 
                  swedish, finnish, danish, scottish gaelic, catalan, hungarian, norwegian and icelandic locale
                  and cyrillic characters.
               Parameters:
                  None  
               Returns:
                  It returns a copy of the string with only its first character capitalized   
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a abC
                  a.capitalize
                  >>>Abc
            ";;&
         center|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               center  
                  This function centers a string in a field of given width. It returns a string 
                  that is at least width characters wide, created by padding the string with the 
                  space character until the given width on the right, left or both sides.
               Parameters:
                  width - integer
               Returns:
                  centered string
               Throws:
                  IllegalArgumentException - if the parameter cannot be treated as a number
                                           - if number of arguments != 1
               Example:
                  String a abc
                  a.center 5
                  >>> abc 
                  echo \"'\$(a.center 5)'\"
                  >>>' abc '
            ";;&   
         charAt|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               charAt
                  Returns the char value at the specified index. An index ranges from 
                  0 to length - 1. The first char value of the sequence is at index 0, 
                  the next at index 1, and so on, as for array indexing.
               Parameters:
                  index - the index of the char value (integer)
               Returns:
                  the char value at the specified index of this string. The first char 
                  value is at index 0.
               Throws:
                  IllegalArgumentException - if the parameter cannot be treated as a number
                                           - if number of arguments != 1
                  IndexOutOfBoundsException - if the index argument is negative or not less than the length of this string.
               Example:
                  String a abc
                  a.charAt 2
                  >>>c
            ";;&
         charCodeAt|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               charCodeAt
                  Returns the character code value at the specified index. An index ranges from
                  0 to length - 1. The first character value of the sequence is at index 0,
                  the next at index 1, and so on, as for array indexing.
               Parameters:
                  index - the index of the character value (integer)
               Returns:
                  the character code value at the specified index of this string.
               Throws:
                  IllegalArgumentException - if the parameter cannot be treated as a number
                                           - if number of arguments != 1
                                           - if invalid character at given index
                  IndexOutOfBoundsException - if the index argument is negative or not less than the length of this string.
               Example:
                  String a abc
                  a.charCodeAt 2
                  >>>99
            ";;&
         compareTo|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               compareTo
                  Compares two strings lexicographically. The comparison is based on the value of each character 
                  in the strings. The character sequence represented by this String object is compared lexicographically 
                  to the character sequence represented by the argument string. The result is a negative integer if this 
                  String object lexicographically precedes the argument string. The result is a positive integer if this 
                  String object lexicographically follows the argument string. The result is zero if the strings are equal; 
                  compareTo returns 0 exactly when the equals(Object) method would return true. 
                  This is the definition of lexicographic ordering. If two strings are different, then either they have 
                  different characters at some index that is a valid index for both strings, or their lengths are different, 
                  or both. If they have different characters at one or more index positions, let k be the smallest such index; 
                  then the string whose character at position k has the smaller value, as determined by using the < operator, 
                  lexicographically precedes the other string. In this case, compareTo returns the difference of the two character 
                  values at position k in the two string -- that is, the value: 
                  this.charAt(k)-anotherString.charAt(k)
                  If there is no index position at which they differ, then the shorter string lexicographically precedes the 
                  longer string. In this case, compareTo returns the difference of the lengths of the strings -- that is, the value: 
                  this.length()-anotherString.length()
               Parameters:
                  anotherString - the primitive string to be compared.
               Returns:
                  the value 0 if the argument string is equal to this String; a value less than 0
                  if this String is lexicographically less than the string argument;
                  and a value greater than 0 if this String is lexicographically greater than the string argument.
               Throws:
                  IllegalArgumentException - if number of arguments != 1
               Example:
                  String a abcd
                  a.compareTo abcd
                  >>>0
                  a.compareTo ab
                  >>>2
                  a.compareTo abcde
                  >>>-1
                  a.compareTo \"\"
                  >>>4
                  a.compareTo x
                  >>>-23
                  a.compareTo \"ab c\"
                  >>>67
               ";;&
         compareToIgnoreCase|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               compareToIgnoreCase
                  Compares a String object with a primitive string lexicographically, ignoring case differences.
                  This method returns an integer whose sign is that of calling
                  compareTo with normalized versions of the String object and the primitive string where case differences
                  have been eliminated.
               Parameters:
                  str - the primitive string to be compared.
               Returns:
                  a negative integer, zero, or a positive integer as the specified primitive string
                  is greater than, equal to, or less than this String, 
                  ignoring case considerations.
               Throws:
                  IllegalArgumentException - if number of arguments != 1
               Example:
                  String x abc
                  x.compareToIgnoreCase abc
                  >>>0
                  x.compareToIgnoreCase aY
                  >>>-23
                  x.compareToIgnoreCase ay
                  >>>-23
            ";;&
         concat|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               concat
                  Concatenates the specified string to the end of this String.
                  If the length of the argument string is 0, then this String object is returned. 
                  Otherwise, a new String object is returned, 
                  representing a character sequence that is the concatenation of the character 
                  sequence represented by this String object and the character sequence represented 
                  by the argument string.
               Parameters:
                  str - the primitive string that is concatenated to the end of this string.
               Returns:
                  a string that represents the concatenation of this object's characters followed 
                  by the string argument's characters
               Throws:
                  IllegalArgumentException - if number of arguments != 1
               Example:
                  String a fff
                  a.concat abc
                  >>>fffabc  
            ";;&
         contains|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               contains
                  Returns true if and only if this String contains the specified sequence of char values.
               Parameters:
                  s - the primitive string to search for
               Returns:
                  true if this String contains s, false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 1
               Example:
                  String a \"abc cd\"
                  a.contains \" c\"
                  >>>true
                  a.contains \"x\"
                  >>>false
            ";;&
         containsNone|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               containsNone
                  Checks that the String does not contain certain characters.
                  An empty String (\"\") always returns true.
               Parameters:
                  invalidChars - a primitive string of invalid chars
               Returns:
                  true if it contains none of the invalid chars, false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 1
               Example:
                  String a \"abc\"
                  a.containsNone \"xyz\"
                  >>>true
                  a.containsNone \"xya\"
                  >>>false
                  a.containsNone \"\$(String.octDigits)\"
                  >>>true
            ";;&
         containsOnly|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               containsOnly
                  Checks if the String contains only certain characters.
                  An empty String (\"\") always returns true.
               Parameters:
                  validChars - a primitive string of valid chars.
               Returns:
                  true if it only contains valid chars, false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 1
               Example:
                  String a \"abc\"
                  a.containsOnly \"cab\"
                  >>>true
                  a.containsOnly \"xab\"
                  >>>false
                  a.containsOnly \"\$(String.asciiLettersLowerCase)\"
                  >>>true
            ";;&
         count|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               count
               Parameters:
                  a primitive string
               Returns:
                  the number of non-overlapping occurrences of parameter in string.  
               Throws:
                  NotInPathException - if bc not in path
                  IllegalArgumentException - if number of arguments != 1
               Example:
                  String a acdccde
                  a.count c
                  >>>3
                  a.count cd
                  >>>2
            ";;&
         endsWith|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               endsWith suffix
                  Tests if this string ends with the specified suffix.
               Parameters:
                  suffix - the suffix (a primitive string).
               Returns:
                  true if the character sequence represented by the argument is a suffix of the 
                  character sequence represented by this object; false otherwise. 
                  Note that the result will be true if the argument is the empty string or is equal 
                  to this String object as determined by the equals Object method.  
               Throws:
                  IllegalArgumentException - if number of arguments != 1
               Example:
                  String a xyz
                  a.endsWith z
                  >>>true
                  a.endsWith yz
                  >>>true
            ";;&
         equals|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               equals
                  Compares this string to the specified object. 
                  The result is true if and only if the argument 
                  is a String object that represents the same sequence of 
                  characters as this object.
               Parameters:
                  anObject - The object to compare this String against
               Returns:
                  true if the given object represents a String equivalent 
                  to this string, false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 1
               Example:
                  String a abc
                  String b abc
                  String c ddd
                  a.equals b
                  >>>true
                  a.equals c
                  >>>false
            ";;&
         equalsIgnoreCase|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               equalsIgnoreCase
                  Optimized for german, french, polish, spanish, romanian, czech, slovak, slovenian, 
                  swedish, finnish, danish, scottish gaelic, catalan, hungarian, norwegian and icelandic locale
                  and cyrillic characters.
                  Compares this String to another String, ignoring case considerations. Two strings 
                  are considered equal ignoring case if they are of the same length and corresponding 
                  characters in the two strings are equal ignoring case.
                  Two characters c1 and c2 are considered the same ignoring case if at least one of 
                  the following is true:
                     * The two characters are the same (as compared by the == operator)
                     * Applying the method Character.toUpperCase(char) to each character produces the same result
                     * Applying the method Character.toLowerCase(char) to each character produces the same result 
               Parameters:
                  aString - The String object to compare this String against
               Returns:
                  true if the argument represents an equivalent String ignoring case; 
                  false otherwise
               Throws:
                  WrongClassException - if argument has the wrong class  
                  IllegalArgumentException - if number of arguments != 1
                                           - if argument is no object
               Example:
                  String a abc
                  String b AbC
                  String c ddd
                  File d abc
                  a.equalsIgnoreCase b
                  >>>true
                  a.equalsIgnoreCase c
                  >>>false 
                  a.equalsIgnoreCase d
                  >>>WrongClassException d: class File
            ";;&
         getClass|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               getClass
                  Returns the runtime class of this Object.
               Parameters:
                 None
               Returns:
                  The Class object that represents the runtime class of this object.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String b xxx
                  b.getClass
                  >>>class String
            ";;& 
         hashCode|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               hashCode
               Parameters:
                  None 
               Returns 
                  a hash code for this string. The hash code for a String object is computed as
                       s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]         
                  using int arithmetic, where s[i] is the ith character of the string, 
                  n is the length of the string, and ^ indicates exponentiation. 
                  (The hash value of the empty string is zero.)  
               Throws:
                  NotInPathException - if bc not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a abcdef
                  a.hashCode
                  >>>-1424385949
            ";;&
         indexOf|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               indexOf
                  Returns the index within this string of the first occurrence of the specified substring, 
                  starting at the specified index. 
                  If no such value exists, then -1 is returned.
                  Simulation of following java behavior:  
                  k >= Math.min(fromIndex, str.length()) && this.startsWith(str, k)
               Parameters:
                  str - the substring to search for.
                  [fromIndex - the index to start the search from.]
               Returns:
                  the index within this string of the first occurrence of the specified substring.
               Throws:
                  IllegalArgumentException - if the index parameter cannot be treated as a number
                                           - if number of arguments != 1 AND != 2
               Examples:
                  String a abc
                  a.indexOf a 
                  >>>0
            ";;&
         indexOfDifference|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               indexOfDifference
                  Compares this String with the given primitive string, and returns the index at which the Strings begin to differ.
               Parameters:
                  str - the primitive string to compare with.
               Returns:
                  the index where str and this String begin to differ; -1 if they are equal
               Throws:
                  IllegalArgumentException - if number of arguments != 1
               Examples:
                  String a ab
                  a.indexOfDifference abxyz
                  >>>2
                  a.indexOfDifference \"\$(a.toString)\"
                  >>>-1
            ";;&
         isAlnum|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               isAlnum
                  based on POSIX standard character class: alnum
               Parameters:
                  None
               Returns:
                  true if all characters in the String are alphanumeric and there is at least one character, 
                  false otherwise.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a a1
                  a.isAlnum
                  >>>true
            ";;&
         isAlpha|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               isAlpha
                  based on POSIX standard character class: alpha
               Parameters:
                  None
               Returns:
                  true if all characters in the String are alphabetic and there is at least one character, 
                  false otherwise.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a abc
                  a.isAlpha
                  >>>true
            ";;&
         isAscii|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               isAscii
                  based on POSIX standard character class: ascii 
               Parameters:
                  None
               Returns:
                  true if all characters in the String are ascii and there is at least one character, 
                  false otherwise.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a \E4\F6\FC
                  a.isAscii
                  >>>false
            ";;&
         isDigit|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               isDigit
                  based on POSIX standard character class: digit
               Parameters:
                  None
               Returns:
                  true if all characters in the String are digits and there is at least one character, 
                  false otherwise.    
               Throws:
                  IllegalArgumentException - if number of arguments != 0 
               Example:
                  String a 23424
                  a.isDigit
                  >>>true
            ";;&
         isEmpty|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               isEmpty
                  Returns true if, and only if, length is 0.
               Parameters:
                  None
               Returns:
                  true if length is 0, otherwise false
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a ""
                  a.isEmpty
                  >>>true
            ";;&
         isHexDigit|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               isHexDigit
                  based on POSIX standard character class: xdigit
               Parameters:
                  None
               Returns:
                  true if all characters in the String are hexdigits and there is at least one character, 
                  false otherwise.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a "a01"
                  a.isHexDigit
                  >>>true 
            ";;&
         isLowerCase|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               isLowerCase
                  Optimized for german, french, polish, spanish, romanian, czech, slovak, slovenian, 
                  swedish, finnish, danish, scottish gaelic, catalan, hungarian, norwegian and icelandic locale
                  and cyrillic characters.
               Parameters:
                  None
               Returns:
                  true if all cased characters in the String are lowercase and there is at least one cased character, 
                  false otherwise.     
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a aBc
                  a.isLowerCase
                  >>>false
            ";;&
         isPrintable|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               isPrintable
                  based on POSIX standard character class: print
               Parameters:
                  None
               Returns:
                  true if all characters in the String are printable and there is at least one character, 
                  false otherwise.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a abc
                  a.isPrintable
                  >>>true 
            ";;&          
         isSpace|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               isSpace
                  based on POSIX standard character class: space
               Parameters:
                  None 
               Returns:
                  true if there are only whitespace characters in the String and there is at least one character, 
                  false otherwise.     
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a \"   \"
                  a.isSpace
                  >>>true
            ";;&
         isTitle|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               isTitle
                  This method checks whether all the case-based characters in the string following non-
                  casebased letters are uppercase and all other case-based characters are lowercase.
               Parameters:
                  None
               Returns:
                  It returns true if the String is a titlecased string and there is at least one character, 
                  for example uppercase characters may only follow uncased characters and lowercase characters 
                  only cased ones. Returns false otherwise.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a 'This Is String Example...Wow!!!'
                  a.isTitle
                  >>>true
            ";;&
         isUpperCase|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               isUpperCase
                  Optimized for german, french, polish, spanish, romanian, czech, slovak, slovenian, 
                  swedish, finnish, danish, scottish gaelic, catalan, hungarian, norwegian and icelandic locale
                  and cyrillic characters.
               Parameters:
                  None
               Returns:
                  true if all cased characters in the String are uppercase and there is at least one cased character,
                  false otherwise.     
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a ABC
                  a.isUpperCase
                  >>>true
            ";;&
         isVisible|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               isVisible
                  based on POSIX standard character class: graph
               Parameters:
                  None
               Returns:
                  true if all characters in the String are visible and there is at least one character, 
                  false otherwise.     
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a \"a c\"
                  a.isVisible
                  >>>false
            ";;&
         lastIndexOf|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               lastIndexOf
                  Returns the index within this String of the last occurrence of the specified substring, 
                  searching backward starting at the specified index. 
                  If no such value exists, then -1 is returned.
               Parameters:
                  str - the substring to search for.
                  [fromIndex - the index to start the search from. 
                  There is no restriction on the value of fromIndex. 
                  If it is greater than or equal to the length of this string, it has the same effect 
                  as if it were equal to one less than the length of this string: this entire string 
                  may be searched. If it is negative, it has the same effect as if it were -1: -1 is returned.]
               Returns:
                  the index within this String of the last occurrence of the specified substring.
               Throws:
                  IllegalArgumentException - if the parameter cannot be treated as a number
                                           - if number of arguments !=1 AND !=2
               Examples:
                  String a \"eacc eadee\"
                  a.lastIndexOf \" e\" 2
                  >>>-1
                  a.lastIndexOf \" e\" 20
                  >>>4
                  a.lastIndexOf e
                  >>>9
            ";;&
         length|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               length
                  Returns the length of this string.
               Parameters:
                  None  
               Returns:
                  the length of the sequence of characters.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a abc
                  a.length
                  >>>3
            ";;&
         lstrip|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               lstrip
               Parameters:
                  None
               Returns:
                  It returns a copy of the String in which all chars have been stripped 
                  from the beginning of the string (whitespace characters).     
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a \"   abc    \"
                  echo \"'\$(a.lstrip)'\"
                  >>>'abc    '
            ";;&
         matches|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               matches
                  Tells whether or not this String matches the given regular expression.
               Parameters:
                  regex - the regular expression to which this string is to be matched
               Returns:
                  true if, and only if, this String matches the given regular expression,
                  false otherwise.
               Throws:
                  IllegalArgumentException - if number of arguments != 1
               Example:
                  String a abc
                  a.matches ^[[:alnum:]]*$
                  >>>true
            ";;&
         replaceAll|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               replaceAll
               Parameters:
                  oldSub
                  newSub
               Returns:
                  Returns a new string resulting from replacing all occurrences
                  of oldSub in this string with newSub.  
               Throws:
                  IllegalArgumentException - if number of arguments != 2
               Example:
                  String a abca
                  a.replaceAll a X
                  >>>XbcX
           ";;&
         replaceFirst|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               replaceFirst
               Parameters:
                  oldSub
                  newSub
               Returns:
                  Returns a new string resulting from replacing the first occurrence 
                  of oldSub in this string with newSub.  
               Throws:
                  IllegalArgumentException - if number of arguments != 2
               Example:
                  String a abca
                  a.replaceFirst a X
                  >>>Xbca 
            ";;& 
         reverse|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               reverse
               Parameters:
                  None
               Returns:
                  a reversed version of the string 
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a AbC
                  a.reverse
                  >>>CbA  
            ";;&
         rstrip|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               rstrip
               Parameters:
                  None
               Returns:
                  It returns a copy of the string in which all chars have been stripped 
                  from the end of the string (whitespace characters).
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a \"   abc    \"
                  echo \"'\$(a.rstrip)'\"
                  >>>'   abc'
            ";;&
         startsWith|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               startsWith
               Parameters:
                  prefix - the prefix string.
                  toffset - where to begin looking in this string. Default: 0
               Returns:
                  true if string starts with parameter string, false otherwise.
               Throws:
                  IllegalArgumentException - if the parameter cannot be treated as a number
                                           - if number of arguments != 1
               Example:
                  String a abcdef
                  a.startsWith ab
                  >>>true
                  a.startsWith d 3
                  >>>true
            ";;&
         substring|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               substring 
               Parameters:
                  beginIndex - the beginning index, inclusive.
                  [endIndex - the ending index, exclusive. Default: end of string]
               Returns:
                  Returns a new string that is a substring of this string. 
                  The substring begins at the specified beginIndex and extends to 
                  the character at index endIndex - 1. 
                  Thus the length of the substring is endIndex-beginIndex.
               Throws:
                  IllegalArgumentException - if the parameter cannot be treated as a number
                                           - if number of arguments != 1 AND != 2
                  IndexOutOfBoundsException - if the beginIndex is negative, or endIndex is larger than the length of this String object, 
                                              or beginIndex is larger than endIndex.   
               Example:
                  String a abcdef
                  a.substring 2 4
                  >>>cd
            ";;&
         swapCase|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               swapCase
               Parameters:
                  None
               Returns:
                  a copy of s, but with lower case letters converted to upper case and vice versa. 
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a AbC
                  a.swapCase
                  >>>aBc     
            ";;&
         title|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               title
               Parameters:
                  None
               Returns:
                  Return a titlecased version of the string: words start with uppercase characters, 
                  all remaining cased characters are lowercase.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a \"AbC...y aber\"
                  a.title
                  >>>Abc...Y Aber  
            ";;&    
         toLowerCase|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               toLowerCase
                  Optimized for german, french, polish, spanish, romanian, czech, slovak, slovenian, 
                  swedish, finnish, danish, scottish gaelic, catalan, hungarian, norwegian and icelandic locale
                  and cyrillic characters.
               Parameters:
                  None
               Returns:
                  A copy of the string with all cased characters in lower case.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a AbC
                  a.toLowerCase
                  >>>abc      
            ";;&
         toString|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               toString
                  This object (which is already a string!) is itself returned.
               Parameters:
                  None
               Returns:
                  the string itself.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a abc
                  a.toString
                  >>>abc
            ";;&
         toUpperCase|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               toUpperCase
                  Optimized for german, french, polish, spanish, romanian, czech, slovak, slovenian, 
                  swedish, finnish, danish, scottish gaelic, catalan, hungarian, norwegian and icelandic locale
                  and cyrillic characters.
               Parameters:
                  None
               Returns:
                  A copy of the string with all cased characters in upper case.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a abc
                  a.toUpperCase
                  >>>ABC     
            ";;&
         trim|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               trim
               Parameters:
                  None
               Returns:
                  A copy of this string with leading and trailing white space removed, or this 
                  string if it has no leading or trailing white space.     
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  String a \"   abc\"
                  a.toString
                  >>>   abc
                  a.trim
                  >>>abc
            ";;&
         zfill|all)
            match=$(Boolean.TRUE)
            System."${printStream}".println "
               zfill
               Parameters:
                  an integer  - The width of the return String
               Returns:
                  Pad a numeric string on the left with zero digits until the given width is reached. 
               Throws:
                  IllegalArgumentException - if the parameter cannot be treated as a number
                                           - if number of arguments != 1
               Example:
                  String a abc
                  a.zfill 5
                  >>>00abc
            ";;&
         *)   
            if [[ "${match}" == "$(Boolean.FALSE)" ]]; then
               System."${printStream}".println "
                     No help found for $1
                  "
            fi
            ;;&
      esac
      shift
   done
}
